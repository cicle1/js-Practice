<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>https://zh.javascript.info/size-and-scroll#shi-li-yuan-su</title>
</head>

<body>
   <!--  总结
    元素具有以下几何属性：

    offsetParent — 是最接近的 CSS 定位的祖先，或者是 td，th，table，body。
    offsetLeft/offsetTop — 是相对于 offsetParent 的左上角边缘的坐标。
    offsetWidth/offsetHeight — 元素的“外部” width/height，边框（border）尺寸计算在内。
    clientLeft/clientTop — 从元素左上角外角到左上角内角的距离。对于从左到右显示内容的操作系统来说，它们始终是左侧/顶部 border 的宽度。而对于从右到左显示内容的操作系统来说，垂直滚动条在左边，所以
    clientLeft 也包括滚动条的宽度。
    clientWidth/clientHeight — 内容的 width/height，包括 padding，但不包括滚动条（scrollbar）。
    scrollWidth/scrollHeight — 内容的 width/height，就像 clientWidth/clientHeight 一样，但还包括元素的滚动出的不可见的部分。
    scrollLeft/scrollTop — 从元素的左上角开始，滚动出元素的上半部分的 width/height。
    除了 scrollLeft/scrollTop 外，所有属性都是只读的。如果我们修改 scrollLeft/scrollTop，浏览器会滚动对应的元素。 -->

    <!-- 
        CSS width 与 clientWidth 的不同点
重要程度: 5
getComputedStyle(elem).width 与 elem.clientWidth 之间有什么不同点？

指出至少三种不同点。当然越多越好。

解决方案
不同点：

clientWidth 值是数值，而 getComputedStyle(elem).width 返回一个以 px 作为后缀的字符串。
getComputedStyle 可能会返回非数值的 width，例如内联（inline）元素的 "auto"。
clientWidth 是元素的内部内容区域加上 padding，而 CSS width（具有标准的 box-sizing）是内部内容区域，不包括 padding。
如果有滚动条，并且浏览器为其保留了空间，那么某些浏览器会从 CSS width 中减去该空间（因为它不再可用于内容），而有些则不会这样做。clientWidth 属性总是相同的：如果为滚动条保留了空间，那么将减去滚动条的大小。
     -->
</body>

</html>