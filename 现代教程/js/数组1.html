<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /* 将 border - left - width 转换成 borderLeftWidth
        重要程度: 5
        编写函数 camelize(str) 将诸如 “my - short - string” 之类的由短划线分隔的单词变成骆驼式的 “myShortString”。

        即：删除所有短横线，并将短横线后的每一个单词的首字母变为大写。

        示例：

        camelize("background-color") == 'backgroundColor';
        camelize("list-style-image") == 'listStyleImage';
        camelize("-webkit-transition") == 'WebkitTransition';
        提示：使用 split 将字符串拆分成数组，对其进行转换之后再 join 回来。

        打开带有测试的沙箱。
 */
        //  解决方案
        /*  function camelize(str) {
             return str
                 .split('-') // splits 'my-long-word' into array ['my', 'long', 'word']
                 .map(
                     // capitalizes first letters of all array items except the first one
                     // converts ['my', 'long', 'word'] into ['my', 'Long', 'Word']
                     (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)
                 )
                 .join(''); // joins ['my', 'Long', 'Word'] into 'myLongWord'
         }
         console.log(camelize("list-style-image")); */


        /* 过滤范围
        重要程度: 4
        写一个函数 filterRange(arr, a, b) ，该函数获取一个数组 arr，在其中查找数值大小在 a 和 b 之间的元素，并返回它们的数组。

        该函数不应该修改原数组。它应该返回新的数组。

        例如：

        let arr = [5, 3, 8, 1];

        let filtered = filterRange(arr, 1, 4);

        alert(filtered); // 3,1（匹配值）

        alert(arr); // 5,3,8,1（未修改） */

        //解决方案
        /* function filterRange(arr, a, b) {
            return arr.filter(item => a <= item && item <= b)
        }
        let arr = [5, 3, 8, 1];

        let filtered = filterRange(arr, 1, 4);

        alert(filtered); // 3,1（匹配的值）

        alert(arr); // 5,3,8,1（未经改动的数组中的值） */

        /*   原位（in place）过滤范围
          重要程度: 4
          写一个函数 filterRangeInPlace(arr, a, b) ，该函数获取一个数组 arr，并删除其中介于 a 和 b 区间以外的所有值。检查：a ≤ arr[i]≤ b。
  
          该函数应该只修改数组。它不应该返回任何东西。
  
          例如：
  
          let arr = [5, 3, 8, 1];
  
          filterRangeInPlace(arr, 1, 4); // 删除了范围在 1 到 4 之外的所有值
  
          alert(arr); // [3, 1] */
        //解决方案
        /* function filterRangeInPlace(arr, a, b) {
            for (let i = 0; i < arr.length; i++) {
                let val = arr[i];

                // 如果超出范围，则删除
                if (val < a || val > b) {
                    arr.splice(i, 1);
                    i--;
                }
            }
        }
        let arr = [5, 3, 8, 1];

        filterRangeInPlace(arr, 1, 4); // 删除 1 到 4 范围之外的值

        alert(arr); // [3, 1] */

        /*  降序排列
         重要程度: 4
         let arr = [5, 2, 1, -10, 8];
 
         // ……你的代码以降序对其进行排序
 
         alert(arr); // 8, 5, 2, 1, -10 */
        //解决方案
        /* let arr = [5, 2, 1, -10, 8];
        arr.sort((a,b)=>b-a)
        alert(arr); */


        /*  复制和排序数组
         重要程度: 5
         我们有一个字符串数组 arr。我们希望有一个排序过的副本，但保持 arr 不变。
 
         创建一个函数 copySorted(arr) 返回这样一个副本。
 
         let arr = ["HTML", "JavaScript", "CSS"];
 
         let sorted = copySorted(arr);
 
         alert(sorted); // CSS, HTML, JavaScript
         alert(arr); // HTML, JavaScript, CSS (no changes) */
        //解决方案
        /* function copySorted(arr) {
            return arr.slice().sort()
        }
        let arr = ["HTML", "JavaScript", "CSS"];

        let sorted = copySorted(arr);

        alert(sorted); // CSS, HTML, JavaScript
        alert(arr); // HTML, JavaScript, CSS (no changes)  */


        /* 
                创建一个可扩展的 calculator
                重要程度: 5
                创建一个构造函数 Calculator，以创建“可扩展”的 calculator 对象。
        
                该任务由两部分组成。
        
                首先，实现 calculate(str) 方法，该方法接受像 "1 + 2" 这样格式为“数字 运算符 数字”（以空格分隔）的字符串，并返回结果。该方法需要能够理解加号 + 和减号 -。
        
                用法示例：
        
                let calc = new Calculator;
        
                alert(calc.calculate("3 + 7")); // 10
                然后添加方法 addMethod(name, func) ，该方法教 calculator 进行新操作。它需要运算符 name 和实现它的双参数函数 func(a, b) 。
        
                例如，我们添加乘法 *，除法 / 和求幂 **：
        
                let powerCalc = new Calculator;
                powerCalc.addMethod("*", (a, b) => a * b);
                powerCalc.addMethod("/", (a, b) => a / b);
                powerCalc.addMethod("**", (a, b) => a ** b);
        
                let result = powerCalc.calculate("2 ** 3");
                alert(result); // 8
                此任务中没有括号或复杂的表达式。
                数字和运算符之间只有一个空格。
                你可以自行选择是否添加错误处理功能。 */
        //解决方案
        /* function Calculator() {
            this.methods = {
                "-": (a, b) => a - b,
                "+": (a, b) => a + b
            };

            this.calculate = function (str) {

                let split = str.split(' '),
                    a = +split[0],
                    op = split[1],
                    b = +split[2]

                if (!this.methods[op] || isNaN(a) || isNaN(b)) {
                    return NaN;
                }

                return this.methods[op](a, b);
            }

            this.addMethod = function (name, func) {
                this.methods[name] = func;
            };
        }
        let powerCalc = new Calculator;
        powerCalc.addMethod("*", (a, b) => a * b);
        powerCalc.addMethod("/", (a, b) => a / b);
        powerCalc.addMethod("**", (a, b) => a ** b);
        console.log(powerCalc)
        let result = powerCalc.calculate("2 ** 3");
        alert(result); */
        /* 映射到 names
        重要程度: 5
        你有一个 user 对象数组，每个对象都有 user.name。编写将其转换为 names 数组的代码。

        例如：

        let john = { name: "John", age: 25 };
        let pete = { name: "Pete", age: 30 };
        let mary = { name: "Mary", age: 28 };

        let users = [john, pete, mary];

        let names =  ... your code 

        alert(names); John, Pete, Mary */
        //解决方案
        /*  let john = { name: "John", age: 25 };
         let pete = { name: "Pete", age: 30 };
         let mary = { name: "Mary", age: 28 };
 
         let users = [john, pete, mary];
 
         let names = users.map(item => item.name);
 
         alert(names); John, Pete, Mary */



        /* 映射到对象
        重要程度: 5
        你有一个 user 对象数组，每个对象都有 name，surname 和 id。

        编写代码以该数组为基础，创建另一个具有 id 和 fullName 的对象数组，其中 fullName 由 name 和 surname 生成。

        例如：

        let john = { name: "John", surname: "Smith", id: 1 };
        let pete = { name: "Pete", surname: "Hunt", id: 2 };
        let mary = { name: "Mary", surname: "Key", id: 3 };

        let users = [john, pete, mary];

        let usersMapped = /* ... your code ... */

        /*
        usersMapped = [
          { fullName: "John Smith", id: 1 },
          { fullName: "Pete Hunt", id: 2 },
          { fullName: "Mary Key", id: 3 }
        ]
        

        alert(usersMapped[0].id) // 1
    alert(usersMapped[0].fullName)  //John Smith */
        //解决方案
        /*  let john = { name: "John", surname: "Smith", id: 1 };
         let pete = { name: "Pete", surname: "Hunt", id: 2 };
         let mary = { name: "Mary", surname: "Key", id: 3 };
 
         let users = [john, pete, mary];
 
         let usersMapped = users.map(user => ({
             fullName: `${user.name} ${user.surname}`,
             id: user.id
         }));
 
         /*
         usersMapped = [
           { fullName: "John Smith", id: 1 },
           { fullName: "Pete Hunt", id: 2 },
           { fullName: "Mary Key", id: 3 }
         ]
        
         console.log(users)
         console.log(usersMapped)
         alert(usersMapped[0].id); // 1
         alert(usersMapped[0].fullName); // John Smith */

        /* 
                按年龄对用户排序
                重要程度: 5
                编写函数 sortByAge(users) 获得对象数组的 age 属性，并根据 age 对这些对象数组进行排序。
        
                例如：
        
                let john = { name: "John", age: 25 };
                let pete = { name: "Pete", age: 30 };
                let mary = { name: "Mary", age: 28 };
        
                let arr = [pete, john, mary];
        
                sortByAge(arr);
        
                // now: [john, mary, pete]
                alert(arr[0].name); // John
                alert(arr[1].name); // Mary
                alert(arr[2].name); // Pete */
/* 
        function sortByAge(arr) {
            arr.sort((a, b) => a.age > b.age ? 1 : -1);
        }

        let john = { name: "John", age: 25 };
        let pete = { name: "Pete", age: 30 };
        let mary = { name: "Mary", age: 28 };

        let arr = [pete, john, mary];

        sortByAge(arr);

        // 排序后的数组为：[john, mary, pete]
        alert(arr[0].name); // John
        alert(arr[1].name); // Mary
        alert(arr[2].name); // Pete */
    </script>
</body>

</html>